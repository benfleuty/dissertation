@using System.Text.RegularExpressions;
@using UploadedFilesLibrary
@using TranscodeNowWebServer.Data
@inject IJSRuntime JSRuntime
@inject Microsoft.AspNetCore.Hosting.IWebHostEnvironment env
@inject NavigationManager nav
@inject IConfiguration config
@inject ISqlDataAccess sql

<link rel="stylesheet" href="css/dragAndDrop.css" />

<div @ref="@dragAndDropContainer" class="drop-zone w-100">
	<form>
		<div @ref="@fileUploadControl">
			<p class="upload-step text-center">Step 1</p>
			<label for="fileInput" class="visually-hidden">Choose your file:</label>
			<InputFile id="fileInput" OnChange="@OnChange" class="form-control" />
			<p class="text-center opacity-75">Or drop a file here</p>
			@if (file is not null)
			{
				string article = "a";
				if (new[] { 'a', 'e', 'i', 'o', 'u' }.Contains(char.ToLower(uploadedFileMime.type[0])))
				{
					article = "an";
				}
				<p>
					You have selected @article @uploadedFileMime.type file.
				</p>
				if (uploadedFileMime.IsSupported == false)
				{
					<p class="text-danger">
						This file type is not supported! Please select an audio or video file.
					</p>
				}

			}
		</div>
		@if (file is not null && uploadedFileMime.IsSupported)
		{
			<div class="mt-4">
				<p class="upload-step text-center">Step 2</p>
				<label for="btnUpload" class="visually-hidden">Click here to upload your file:</label>
				<button class="btn btn-primary my-2 form-control" @onclick="BtnUploadFile" type="button" disabled="@DisableUploadButton">Upload</button>
			</div>
		}
	</form>
</div>

@code {

	ElementReference dragAndDropContainer;
	ElementReference fileUploadControl;
	IJSObjectReference? _module;
	IJSObjectReference? _dropZoneInstance;

	bool DisableUploadButton = false;

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			_module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "/js/dragAndDrop.js") ?? throw new FileNotFoundException("Could not load dragAndDrop.js");
			_dropZoneInstance = await _module.InvokeAsync<IJSObjectReference>("initialiseFileDropZone", dragAndDropContainer, fileUploadControl);
			string uploadPath = $@"{env.WebRootPath}\uploads\";

			if (Directory.Exists(uploadPath) == false)
				Directory.CreateDirectory(uploadPath);

			foreach (string file in Directory.GetFiles($@"{env.WebRootPath}\uploads\"))
			{
				File.Delete(file);
			}
		}
	}

	IBrowserFile? file;
	struct MIME
	{
		public string type;
		public string subtype;
		public MIME(string t, string s)
		{
			type = t;
			subtype = s;
		}

		public override string ToString()
		{
			return $"{type}/{subtype}";
		}

		public bool IsSupported => type == "audio" || type == "video";
	}

	MIME uploadedFileMime;
	async Task OnChange(InputFileChangeEventArgs e)
	{
		file = null;
		var uploaded = e.File;
		var parts = uploaded.ContentType.Split("/");
		string type = parts[0];
		string subtype = parts[1];
		uploadedFileMime = new MIME(type, subtype);
		file = uploaded;
		DisableUploadButton = false;
	}

	async Task<Stream?> GetStreamFromFile()
	{
		if (file is null)
		{
			await _module.InvokeVoidAsync("log", "No file given - will not upload");
			return null;
		}

		try
		{
			return file.OpenReadStream(file.Size);
		}
		catch (Exception)
		{
			await _module.InvokeVoidAsync("log", "There was an error reading the file");
			return null;
		}
	}

	async Task<bool> InsertFileNameIntoDatabase(UploadedFileModel fileModel)
	{
		try
		{
			await sql.SaveData(UploadedFilesLibrary.StoredProcedures.FILE_INSERT,
								"localhost-docker",
								fileModel);
			return true;
		}
		catch (Exception e)
		{
			await _module.InvokeVoidAsync("log", $"There was an error writing to the SQL database\n{e.Message}");
			return false;
		}
	}

	async Task<bool> UploadToFileServer(Stream stream, UploadedFileModel uploadedFileModel)
	{
		if (stream.Length < 1)
		{
			// todo throw up an error message as no file is given
			await _module.InvokeVoidAsync("log", "No file given - will not upload");
			DisableUploadButton = false;
			return false;
		}

		string filePath = $@"{env.WebRootPath}\uploads\{uploadedFileModel.RandomFileName}";
		FileStream fsW = File.Create(filePath);
		await stream.CopyToAsync(fsW);
		stream.Close();
		fsW.Close();
		return await FileUploader.UploadFile(filePath);
	}

	async Task<bool> SendTranscodeMessage(){
		return true;
	}

	async Task BtnUploadFile()
	{
		DisableUploadButton = true;

		var stream = await GetStreamFromFile();
		if (stream is null || file is null)
		{
			DisableUploadButton = false;
			return;
		}

		var newFileName = Path.ChangeExtension(
			Path.GetRandomFileName(),
			Path.GetExtension(file.Name));

		// create file model
		var fileModel = new UploadedFileModel()
			{
				OriginalFileName = Path.GetFileNameWithoutExtension(file.Name),
				RandomFileName = newFileName
			};


		// upload to fileserver
		var uploadTask = await UploadToFileServer(stream,fileModel);

		// enter filename into database
		var insertTask = await InsertFileNameIntoDatabase(fileModel);

		// send message that file is ready to be transcoded
		var messageTask = await SendTranscodeMessage();

		// todo enter random filename into redis

		//// SQL
		var databaseResult = insertTask;
		if(databaseResult == false)
		{
			return;
		}

		//// Upload
		var uploadResult = uploadTask;
		if(uploadResult == false)
		{
			return;
		}

		//// Transcode Message
		var messageResult = messageTask;
		if(messageResult == false)
		{
			return;
		}

		// redirect to transcoding progress page
		nav.NavigateTo("/transcode");
	}
}